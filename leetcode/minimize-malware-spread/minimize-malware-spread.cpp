#include "../header.h"

#include <lib/unionFindDense.h>

class Solution {
public:
    int minMalwareSpread(const vector<vector<int>>& graph, const vector<int>& initial) {
        const int n = graph.size();
        UnionFindDense uf(n);
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (i != j && graph[i][j]) {
                    uf.unite(i, j);
                }
            }
        }

        auto p2c = uf.parentToComponent();

        int min = 1234567890;
        int minIndex = 0;

        for (int i = 0; i < initial.size(); ++i) {
            int now = 0;
            vector<size_t> nowV;

            for (int j = 0; j < initial.size(); ++j) {
                if (i != j) {
                    catInplace(nowV, p2c[uf.find(initial[j])]);
                }
            }
            sortAndUnique(nowV);
            now = nowV.size();

            if ((now < min) || (now == min && initial[i] < initial[minIndex])) {
                min = now;
                minIndex = i;
            }
        }

        return initial[minIndex];
    }
};

int main() {
    Solution sol;
    Timer t("Subarray timer");
    cerr << sol.minMalwareSpread({{1, 1, 0}, {1, 1, 0}, {0, 0, 1}}, {0, 1}) << endl;
    cerr << sol.minMalwareSpread({{1, 1, 1}, {1, 1, 1}, {1, 1, 1}}, {1, 2}) << endl;
    cerr << sol.minMalwareSpread({{1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1},
                                  {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0},
                                  {0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0},
                                  {0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0},
                                  {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0},
                                  {0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0},
                                  {0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
                                  {0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0},
                                  {0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0},
                                  {0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0},
                                  {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}},
                                 {7, 8, 6, 2, 3})
         << endl;

    return 0;
}
